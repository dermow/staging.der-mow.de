---
layout: post
title:  "Terraform #02 - Installation und die wichtigsten Commands"
date:   2022-10-13 10:00:42 +0100
categories: Terraform
---

Heyho,

im zweiten Teil der Terraform-Reihe möchte ich kurz auf die (sehr simple) Installation von Terraform eingehen und euch die wichtigsten Befehle
kurz erklären.


### Installation

Die Installation ist sehr simpel und kann aus einem der Hashicorp-Repositories erfolgen. Beispielhaft für Debian/Ubuntu:

```bash
wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
```

Das ganze für weitere Paket-Manger findet ihr hier:

[https://www.terraform.io/downloads](https://www.terraform.io/downloads)

<!-- excerpt-end -->

Nachdem das erledigt ist, könnt ihr testen ob terraform installiert wurde:

```bash
terraform --version

Terraform v1.3.0
on linux_amd64
```

### Die wichtigsten Befehle

#### terraform init
Mit "init" initialisieren wir unser Terraform-Projekt. Dies müssen wir immer beim ersten mal tun, sowie immer, wenn wir änderungen an der Backend-Konfiguration vornehmen.

```bash
terraform init
```

Beim Beispielprojekt aus Teil 1 sieht der Output z.B. folgendermaßen aus:
```
❯ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/aws...
- Installing hashicorp/aws v4.34.0...
- Installed hashicorp/aws v4.34.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```

### terraform plan
Mit "plan" können wir uns anzeigen lassen, welche Änderungen Terraform durchführen "würde". Dabei können wir diese direkt in ein sogenanntes "Planfile" 
speichern, um die Änderungen dann später 1:1 so zu übernehmen.

Zur Übersichtlichkeit hier nochmal unser kleines Beispielprojekt:

```terraform
// Provider Konfiguration
provider "aws" {
  region = "eu-central-1"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}


// Mit der Datasource finden wir ein existierendes AMI
data "aws_ami" "ubuntu-ami" {
  most_recent = true

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }

  owners = ["099720109477"] # Canonical
}

// Ressource: EC2-Instanz
resource "aws_instance" "my-instance" {
  ami           = data.aws_ami.ubuntu-ami.id
  instance_type = "t3.micro"

  tags = {
    Name = "HelloWorld"
  }
}
```

```bash
terraform plan --out /tmp/my-plan-file
```
Output:
```
❯ terraform plan --out /tmp/my-plan-file
data.aws_ami.ubuntu-ami: Reading...
data.aws_ami.ubuntu-ami: Read complete after 0s [id=ami-011c971da0e71c495]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with
the following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.my-instance will be created
  + resource "aws_instance" "my-instance" {
      + ami                                  = "ami-011c971da0e71c495"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t3.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = (known after apply)
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "HelloWorld"
        }
      + tags_all                             = {
          + "Name" = "HelloWorld"
        }
      + tenancy                              = (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification {
          + capacity_reservation_preference = (known after apply)

          + capacity_reservation_target {
              + capacity_reservation_id                 = (known after apply)
              + capacity_reservation_resource_group_arn = (known after apply)
            }
        }

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + tags                  = (known after apply)
          + throughput            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + enclave_options {
          + enabled = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + maintenance_options {
          + auto_recovery = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
          + instance_metadata_tags      = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_card_index    = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + private_dns_name_options {
          + enable_resource_name_dns_a_record    = (known after apply)
          + enable_resource_name_dns_aaaa_record = (known after apply)
          + hostname_type                        = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + tags                  = (known after apply)
          + throughput            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.

─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Saved the plan to: /tmp/my-plan-file

To perform exactly these actions, run the following command to apply:
    terraform apply "/tmp/my-plan-file"

```

Wie wir sehen möchte Terraform eine ressource anlegen (add), keine ändern (change), und auch keine löschen (destroy).

In der letzten Zeile sehen wir nun auch, wie wir den soeben angelegten Plan übernehmen können.
